title: Dependency inversion principle in Go
date: 2019-06-06 14:54:25
tags:
---

# 依赖反转原则在Go中使用
## 依赖反转原则

[面向对象设计的设计原则](https://en.wikipedia.org/wiki/SOLID)有五个，分别是:

|首字母|  指代 |   概念|
|--|--|--|
| S |  单一功能原则 |   认为对象应该仅具有一种单一功能的概念。|
| O |  开闭原则     |   认为“软件体应该是对于扩展开放的，但是对于修改封闭的”的概念。|
| L |  里氏替换原则 |   认为“程序中的对象应该是可以在不改变程序正确性的前提下被它的子类所替换的”的概念。  参考契约式设计。|
| I |  接口隔离原则 |   认为“多个特定客户端接口要好于一个宽泛用途的接口” 的概念。|
| D |  依赖反转原则 |   认为一个方法应该遵从“依赖于抽象而不是一个实例” 的概念。 依赖注入是该原则的一种实现方式。|

这五个原则简称: `SOLID`。
在面向对象编程领域中，依赖反转原则（Dependency inversion principle，DIP）是指一种特定的解耦（传统的依赖关系创建在高层次上，而具体的策略设置则应用在低层次的模块上）形式，使得高层次的模块不依赖于低层次的模块的实现细节，依赖关系被颠倒（反转），从而使得低层次模块依赖于高层次模块的需求抽象。
该原则规定：

* 高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口。
* 抽象接口不应该依赖于具体实现。而具体实现则应该依赖于抽象接口。

该原则颠倒了一部分人对于面向对象设计的认识方式。如高层次和低层次对象都应该依赖于相同的抽象接口。

在传统的应用架构中，低层次的组件设计用于被高层次的组件使用，这一点提供了逐步的构建一个复杂系统的可能。在这种结构下，高层次的组件直接依赖于低层次的组件去实现一些任务。这种对于低层次组件的依赖限制了高层次组件被重用的可行性。

依赖反转原则的目的是把高层次组件从对低层次组件的依赖中解耦出来，这样使得重用不同层级的组件实现变得可能。把高层组件和低层组件划分到不同的包/库（在这些包/库中拥有定义了高层组件所必须的行为和服务的接口，并且存在高层组件的包）中的方式促进了这种解耦。由于低层组件是对高层组件接口的具体实现，因此低层组件包的编译是依赖于高层组件的，这颠倒了传统的依赖关系。众多的设计模式，比如插件，服务定位器或者依赖反转，则被用来在运行时把指定的低层组件实现提供给高层组件。

应用依赖反转原则同样被认为是应用了[适配器模式](https://zh.wikipedia.org/wiki/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F)，例如：高层的类定义了它自己的适配器接口（高层类所依赖的抽象接口）。被适配的对象同样依赖于适配器接口的抽象（这是当然的，因为它实现了这个接口），同时它的实现则可以使用它自身所在低层模块的代码。通过这种方式，高层组件则不依赖于低层组件，因为它（高层组件）仅间接的通过调用适配器接口多态方法使用了低层组件，而这些多态方法则是由被适配对象以及它的低层模块所实现的。

>**前面一大堆其实都是从wiki上copy过来的，自己的理解有以下几点:**
* 上层指**调用者**, 下层指**被调用者**
* 原来的编程方式是上层调用下层的时候依赖下层具体的实现方式
* 依赖反转（或叫:依赖倒置)是指下层的实现依赖上层调用的需求
* 最终的解决方式是: 把上层的需求抽象成接口，上层依赖接口的抽象进行调用，下层依赖接口的抽象进行实现(下面要介绍的**面相接口编程**)


### 依赖注入
[依赖注入](https://zh.wikipedia.org/wiki/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5)是种实现控制反转用于解决依赖性设计模式。一个依赖关系指的是可被利用的一种对象（即服务提供端） 。依赖注入是将所依赖的传递给将使用的从属对象（即客户端）。该服务是将会变成客户端的状态的一部分。 传递服务给客户端，而非允许客户端来建立或寻找服务，是本设计模式的基本要求。

>**上面这段也是wiki上的, 自己理解:**
* 依赖注入就是: 把下层依赖注入(或叫传递)到上层调用
* 要把提供服务的一方(也就是前面说的: 下层)作为实例传递给客户端(即:上层)
* 不要客户端在内部自己实现服务端的实例化。
* 这种方式的好处是: 可以通过传递不同的实例化对象来实现多态。

### 面相接口编程
[面相接口编程](https://zh.wikipedia.org/wiki/%E5%9F%BA%E4%BA%8E%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B)是前面实现依赖反转原则的具体方式。
基于接口的编程将应用程序定义为组件的集合，其中组件间的应用程序接口（API）调用可能只通过抽象化接口完成，而没有具体的类。类的实例化一般通过使用如[工厂模式](https://zh.wikipedia.org/wiki/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95#%E5%B7%A5%E5%8E%82)等技术的其他接口完成。

> **这里也说一点自己的理解:**
上面说到要通过依赖注入方式传递实例，这个实例如何生成呢？如果每次都生成一个，如果这个实例是有状态的，那么每个拿到的可能都是不一样的，这样就**无法共享**。所以一般都是通过工厂模式产生一个实例，其他调用方要共享的话都通过这个工厂拿到**同一个实例**。


另一种定义描述: 在系统分析和架构中，分清层次和依赖关系，每个层次不是直接向其上层提供服务（即不是直接实例化在上层中），而是通过定义一组接口，仅向上层暴露其接口功能，上层对于下层仅仅是接口依赖，而不依赖具体类

#### 面向接口编程和面向对象编程是什么关系:
首先，面向接口编程和面向对象编程并不是平级的，它并不是比面向对象编程更先进的一种独立的编程思想，而是附属于面向对象思想体系，属于其一部分。或者说，它是面向对象编程体系中的思想精髓之一。

#### 接口的本质

#####  接口是一组规则的集合，它规定了实现本接口的类或接口必须拥有的一组规则。体现了自然界“如果你是……则必须能……”的理念

例如，在自然界中，人都能吃饭，即“如果你是人，则必须能吃饭”。那么模拟到计算机程序中，就应该有一个Person接口，并有一个方法叫Eat()，然后我们规定，每一个表示“人”的类，必须实现Person接口，这就模拟了自然界“如果你是人，则必须能吃饭”这条规则。

从这里，我想各位也能看到些许面向对象思想的东西。面向对象思想的核心之一，就是模拟真实世界，把真实世界中的事物抽象成类，整个程序靠各个类的实例互相通信、互相协作完成系统功能，这非常符合真实世界的运行状况，也是面向对象思想的精髓。

##### 接口是在一定粒度视图上同类事物的抽象表示。注意这里我强调了在一定粒度视图上，因为“同类事物”这个概念是相对的，它因为粒度视图不同而不同

例如，在我的眼里，我是一个人，和一头猪有本质区别，我可以接受我和我同学是同类这个说法，但绝不能接受我和一头猪是同类。但是，如果在一个动物学家眼里，我和猪应该是同类，因为我们都是动物，他可以认为“人”和“猪”都实现了Animal这个接口，而他在研究动物行为时，不会把我和猪分开对待，而会从“动物”这个较大的粒度上研究，但他会认为我和一棵树有本质区别。

#### 面相接口编程的优点

* 首先对系统灵活性大有好处。当下层需要改变时，只要接口及接口功能不变，则上层不用做任何修改。甚至可以在不改动上层代码时将下层整个替换掉。
* 使用接口的另一个好处就是不同部件或层次的开发人员可以并行开工。

> **关于面相接口编程的归纳:**
* 面相接口是面向对象编程的重要部分
* 接口本质上是一组规则的集合，是一定粒度上有相同特指的对象的的抽象
* 面相接口编程可以提高编程的灵活性, 可以并行开发。

## Go 中的应用

### Go 中的接口
Go语言中，接口(interface)有其特殊的地方, 其他的语言一般要实现一个接口都需要显示的说明
例如`PHP`(这里没有贬低PHP的意思，大多数语言也是这种实现方式例如`C++`, `Python`, `Rust`等):
```php
<?php

// Declare the interface 'iTemplate'
interface iTemplate
{
    public function setVariable($name, $var);
    public function getHtml($template);
}

// Implement the interface
// This will work
class Template implements iTemplate
{
    private $vars = array();
  
    public function setVariable($name, $var)
    {
        $this->vars[$name] = $var;
    }
  
    public function getHtml($template)
    {
        foreach($this->vars as $name => $value) {
            $template = str_replace('{' . $name . '}', $value, $template);
        }
 
        return $template;
    }
}

```
用到关键字 `implements`。
todo: 对比优缺点

而`Go`语言中，`interface`是`duck typing`(鸭子类型: If it looks like a duck, and it quacks like a duck, then it is a duck), 也就是如果一个对象实现了某个接口的方法，那么这个对象就是这个接口类型了，不需要显示说明是否实现了某个接口。

```go
// Speaker types can say things.
type Speaker interface {
  Say(string)
}

// Person is a strut with filed name
type Person struct {
  name string
}

// Say funciton is defined by Speaker and implement by Person
func (p *Person) Say(message string) {
  log.Println(p.name+":", message)
}
```
上面`Person`实现了函数`Say`, 所以`Person`就是`Speaker`类型了。





### Go 中面相接口编程

### 测试

### 自己的实现

## 参考

[面向对象设计的设计原则](https://en.wikipedia.org/wiki/SOLID)
[依赖注入](https://zh.wikipedia.org/wiki/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5)
[面相接口编程](https://zh.wikipedia.org/wiki/%E5%9F%BA%E4%BA%8E%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B)
[面向接口编程详解（一）——思想基础](https://www.cnblogs.com/leoo2sk/archive/2008/04/10/1146447.html)
[如何写出优雅的 Golang 代码](https://mp.weixin.qq.com/s/FnKkZD4DdPVX7PPH3dY8-w)
[使用Golang的interface接口设计原则](https://gocn.vip/article/1764)
[Duck typing in Go](https://medium.com/@matryer/golang-advent-calendar-day-one-duck-typing-a513aaed544d)
